{"version":3,"sources":["store.js","store.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Store","_NGN$EventEmitter","cfg","this","_this","getPrototypeOf","model","NGN","_data","_filters","_index","index","_created","_deleted","_loading","_softarchive","proxy","allowDuplicates","coalesce","errorOnDuplicate","autoRemoveExpiredRecords","privateconst","softDelete","softDeleteTtl","forEach","events","BUS","eventName","on","args","slice","arguments","shift","push","emit","data","suppressEvent","record","DATA","Entity","JSON","parse","e","Error","hasOwnProperty","_store","dupe","isDuplicate","listen","applyIndices","indexOf","undefined","insert","position","add","move","filter","rec","checksum","_this2","delta","updateIndice","field","old","expired","remove","event","_this3","array","Array","isArray","bulk","clear","findIndex","el","suppressEvents","_this4","removedRecord","dataIndex","Model","m","toString","splice","unapplyIndices","once","purgeDeletedRecord","expires","source","stack","pop","path","console","warn","css","purgedRecord","findArchivedRecord","removeAllListeners","_this5","purge","keys","query","ignoreFilters","_this6","resultSet","_ret3","indice","getIndices","idAttribute","trim","v","recordSet","contains","match","noindex","queryKeys","concat","x","map","y","applyFilters","fn","removed","_this7","records","stringify","dupes","find","duplicate","_this8","sort","functionKeys","a","b","toLowerCase","fields","localeCompare","reindex","exists","store","_this9","_this10","deleteIndex","number","_this11","indexes","values","num","_this12","oldValue","newValue","ct","unshift","dataArray","getRecordIndex","oldIndex","newIndex","id","_this13","clearIndices","get","d","EventEmitter"],"mappings":"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","file":"store.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\nclass Store extends NGN.EventEmitter {\n  constructor (cfg) {\n    cfg = cfg || {}\n    super(cfg)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n      _softarchive: NGN.private([]),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true)),\n\n      /**\n       * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n       * When set to `true`, the store will automatically delete expired records.\n       */\n      autoRemoveExpiredRecords: NGN.privateconst(NGN.coalesce(cfg.autoRemoveExpiredRecords, true)),\n\n      /**\n       * @cfg {boolean} [softDelete=false]\n       * When set to `true`, the store makes a copy of a record before removing\n       * it from the store. The store will still emit a `record.delete` event,\n       * and it will still behanve as though the record has been completely\n       * removed. However; the record copy can be retrieved using the #restore\n       * method.\n       *\n       * Since it is not always desirable to store a copy of every deleted\n       * record indefinitely, it is possible to expire and permanently remove\n       * records by setting the #softDeleteTtl.\n       *\n       * ```js\n       * var People = new NGN.DATA.Store({\n       *   model: Person,\n       *   softDelete: true,\n       *   softDeleteTtl: 10000\n       * })\n       *\n       * People.add(somePerson)\n       *\n       * var removedRecordId\n       * People.once('record.delete', function (record) {\n       *   removedRecordId = record.id\n       * })\n       *\n       * People.remove(somePerson)\n       *\n       * setTimeout(function () {\n       *   People.restore(removedRecordId)\n       * }, 5000)\n       *\n       * ```\n       *\n       * The code above creates a new store and adds a person to it.\n       * Then a placeholder variable (`removedRecordId`) is created.\n       * Next, a one-time event listener is added to the store, specifically\n       * for handling the removal of a record. Then the record is removed,\n       * which triggers the `record.delete` event, which populates\n       * `removedRecordId` with the ID of the record that was deleted.\n       * Finally, the code waits for 5 seconds, then restores the record. If\n       * the #restore method _wasn't_ called, the record would be purged\n       * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n       * milliseconds).\n       */\n      softDelete: NGN.privateconst(NGN.coalesce(cfg.softDelete, false)),\n\n      /**\n       * @cfg {number} [softDeleteTtl=-1]\n       * This is the number of milliseconds the store waits before purging a\n       * soft-deleted record from memory. `-1` = Infinite (no TTL).\n       */\n      softDeleteTtl: NGN.private(NGN.coalesce(cfg.softDeleteTtl, -1))\n    })\n\n    let obj = {}\n    this._index.forEach(i => {\n      obj[i] = []\n    })\n\n    this._index = obj\n\n    const events = [\n      'record.duplicate',\n      'record.create',\n      'record.update',\n      'record.delete',\n      'record.restored',\n      'record.purged',\n      'record.move',\n      'clear',\n      'filter.create',\n      'filter.delete',\n      'index.create',\n      'index.delete'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(eventName => {\n        this.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.shift()\n          args.push(this)\n          NGN.BUS.emit(eventName, args)\n        })\n      })\n    }\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n  get data () {\n    return this._data.map(function (d) {\n      return d.data\n    })\n  }\n\n  /**\n   * @property {array} records\n   * An array of NGN.DATA.Model records. If the store has\n   * filters applied, the records will reflect the filtration.\n   * @readonly\n   */\n  get records () {\n    return this.applyFilters(this._data)\n  }\n\n  /**\n   * @property recordCount\n   * The total number of #records in the collection.\n   * @readonly\n   */\n  get recordCount () {\n    return this.applyFilters(this._data).length\n  }\n\n  /**\n   * @property {array} filtered\n   * An array of NGN.DATA.Model records that have been filtered out.\n   * The results reflect the inverse of #records.\n   */\n  get filtered () {\n    let records = this.records\n    return this._data.filter(function (record) {\n      return records.filter(function (rec) {\n        return rec.checksum === record.checksum\n      }).length === 0\n    })\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[0]\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[this.records.length - 1]\n  }\n\n  /**\n   * @method add\n   * Add a data record.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvent) {\n    let record\n\n    if (!(data instanceof NGN.DATA.Entity)) {\n      try { data = JSON.parse(data) } catch (e) {}\n      if (typeof data !== 'object') {\n        throw new Error('Cannot add a non-object record.')\n      }\n      if (this.model) {\n        record = new this.model(data) // eslint-disable-line new-cap\n      } else {\n        record = data\n      }\n    } else {\n      record = data\n    }\n\n    if (record.hasOwnProperty('_store')) {\n      record._store = this\n    }\n\n    let dupe = this.isDuplicate(record)\n    if (dupe) {\n      this.emit('record.duplicate', record)\n      if (!this.allowDuplicates) {\n        if (this.errorOnDuplicate) {\n          throw new Error('Cannot add duplicate record (allowDuplicates = false).')\n        }\n        return\n      }\n    }\n\n    this.listen(record)\n    this.applyIndices(record, this._data.length)\n    this._data.push(record)\n    !this._loading && this._created.indexOf(record) < 0 && this._created.push(record)\n    !NGN.coalesce(suppressEvent, false) && this.emit('record.create', record)\n    return record\n  }\n\n  /**\n   * @method insertBefore\n   * Add a record before the specified index.\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added before.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertBefore (index, data, suppressEvent = false) {\n    return this.insert(index, data, suppressEvent, 'before')\n  }\n\n  /**\n   * @method insertAfter\n   * Add a record after the specified index.\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added after.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertAfter (index, data, suppressEvent = false) {\n    return this.insert(index + 1, data, suppressEvent, 'after')\n  }\n\n  /**\n   * @method insert\n   * Add a record somewhere within the existing recordset (as opposed to simply appending).\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added after.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @param {string} [position=after]\n   * The position (before or after) where the record should be added.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insert (index, data, suppressEvent = false, position = 'after') {\n    let record = this.add(data, true)\n    if (record) {\n      this.move(this._data.length - 1, index, position, false)\n\n      if (!suppressEvent) {\n        this.emit('record.create', record)\n      }\n    }\n\n    return record\n  }\n\n  /**\n   * @method isDuplicate\n   * Indicates whether the specified record is a duplicate.\n   * This compares checksum values. Any match is considered a\n   * duplicate. It will also check for duplication of raw JSON\n   * objects (i.e. non-NGN.DATA.Model records).\n   * @param  {NGN.DATA.Model|Object} record\n   * The record or JSON object.\n   * @return {boolean}\n   */\n  isDuplicate (record) {\n    if (this._data.indexOf(record) >= 0) {\n      return false\n    }\n    return this._data.filter(function (rec) {\n      return rec.checksum === record.checksum\n    }).length > 0\n  }\n\n  /**\n   * @method listen\n   * Listen to a specific record's events and respond.\n   * @param {NGN.DATA.Model} record\n   * The record to listen to.\n   * @fires record.update\n   * Fired when a record is updated. The #record is passed as an argument to\n   * the event handler.\n   * @private\n   */\n  listen (record) {\n    record.on('field.update', delta => {\n      this.updateIndice(delta.field, delta.old, delta.new, this._data.indexOf(record))\n      this.emit('record.update', record, delta)\n    })\n\n    record.on('field.delete', delta => {\n      this.updateIndice(delta.field, delta.old, undefined, this._data.indexOf(record))\n      this.emit('record.update', record, delta)\n    })\n\n    record.on('expired', () => {\n      if (!record.expired) {\n        return\n      }\n\n      this.emit('record.expired', record)\n\n      if (this.autoRemoveExpiredRecords) {\n        this.remove(record)\n      }\n    })\n  }\n\n  /**\n   * @method bulk\n   * Bulk load data.\n   * @param {string} eventName\n   * @param {array} data\n   * @private\n   */\n  bulk (event, data) {\n    this._loading = true\n\n    data.forEach(record => {\n      this.add(record, true)\n    })\n\n    this._loading = false\n    this._deleted = []\n    this._created = []\n\n    this.emit(event || 'load')\n  }\n\n  /**\n   * @method load\n   * Bulk load data. This acts the same as adding records,\n   * but it suppresses individual record creation events.\n   * This will add data to the existing collection. If you\n   * want to load fresh data, use the #reload method.\n   * @param {array} data\n   * An array of data. Each array element should be an\n   * NGN.DATA.Model or a JSON object that can be applied\n   * to the store's #model.\n   */\n  load () {\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('load', array)\n  }\n\n  /**\n   * @method reload\n   * Reload data. This is the same as running #clear followed\n   * by #load.\n   */\n  reload (data) {\n    this.clear()\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('reload', array)\n  }\n\n  /**\n   * @method indexOf\n   * Find the index number of a record within the collection.\n   * @param  {NGN.DATA.Model} record\n   * The record whose index should be identified.\n   * @return {Number}\n   * Returns a number from `0-collection length`. Returns `-1` if\n   * the record is not found in the collection.\n   */\n  indexOf (record) {\n    if (typeof record !== 'object' || (!(record instanceof NGN.DATA.Entity) && !record.checksum)) {\n      return -1\n    }\n\n    return this._data.findIndex(function (el) {\n      return el.checksum === record.checksum\n    })\n  }\n\n  /**\n   * @method contains\n   * A convenience method that indicates whether a record is in\n   * the store or not.\n   * @param {NGN.DATA.Model} record\n   * The record to check for inclusion in the data collection.\n   * @return {Boolean}\n   */\n  contains (record) {\n    return this.indexOf(record) >= 0\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|object|number} data\n   * Accepts an existing NGN Data Model, JSON object,\n   * or index number. Using a JSON object is slower\n   * than using a reference to a data model or an index\n   * number (index is fastest).\n   * @fires record.delete\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (data, suppressEvents) {\n    let removedRecord = []\n    let dataIndex\n\n    if (typeof data === 'number') {\n      dataIndex = data\n    } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n      dataIndex = this.indexOf(data)\n    } else {\n      let m = new this.model(data, true) // eslint-disable-line new-cap\n      dataIndex = this._data.findIndex(function (el) {\n        return el.checksum === m.checksum\n      })\n    }\n\n    // If no record is found, the operation fails.\n    if (dataIndex < 0) {\n      throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').')\n    }\n\n    removedRecord = this._data.splice(dataIndex, 1)\n\n    if (removedRecord.length > 0) {\n      removedRecord = removedRecord[0]\n      this.unapplyIndices(dataIndex)\n\n      if (this.softDelete) {\n        if (this.softDeleteTtl >= 0) {\n          const checksum = removedRecord.checksum\n          removedRecord.once('expired', () => {\n            this.purgeDeletedRecord(checksum)\n          })\n\n          removedRecord.expires = this.softDeleteTtl\n        }\n\n        this._softarchive.push(removedRecord)\n      }\n\n      if (!this._loading) {\n        let i = this._created.indexOf(removedRecord)\n        if (i >= 0) {\n          i >= 0 && this._created.splice(i, 1)\n        } else if (this._deleted.indexOf(removedRecord) < 0) {\n          this._deleted.push(removedRecord)\n        }\n      }\n\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('record.delete', removedRecord)\n      }\n\n      return removedRecord\n    }\n\n    return null\n  }\n\n  /**\n   * @method findArchivedRecord\n   * Retrieve an archived record.\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {object}\n   * Returns the archived record and it's index within the deletion archive.\n   * ```js\n   * {\n   *   index: <number>,\n   *   record: <NGN.DATA.Model>\n   * }\n   * ```\n   * @private\n   */\n  findArchivedRecord (checksum) {\n    let index\n    let record = this._softarchive.filter((record, i) => {\n      if (record.checksum === checksum) {\n        index = i\n        return true\n      }\n    })\n\n    if (record.length !== 1) {\n      let source\n      try {\n        source = NGN.stack.pop().path\n      } catch (e) {\n        source = 'Unknown'\n      }\n\n      console.warn('Cannot purge record. %c' + record.length + ' records found%c. Source: %c' + source, NGN.css, '', NGN.css)\n      return null\n    }\n\n    return {\n      index: index,\n      record: record[0]\n    }\n  }\n\n  /**\n   * @method purgeDeletedRecord\n   * Remove a soft-deleted record from the store permanently.\n   * This cannot be undone, and there are no events for this action.\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {NGN.DATA.Model}\n   * Returns the purged record. This will be `null` if the record cannot be\n   * found or does not exist.\n   * @fires {NGN.DATA.Model} record.purged\n   * This event is triggered when a record is removed from the soft-delete\n   * archive.\n   * @private\n   */\n  purgeDeletedRecord (checksum) {\n    const purgedRecord = this.findArchivedRecord(checksum)\n\n    // If there is no record, abort (the findArchivedRecord emits a warning)\n    if (purgedRecord === null) {\n      return null\n    }\n\n    this._softarchive.splice(purgedRecord.index, 1)\n\n    this.emit('record.purged', purgedRecord.record)\n\n    return purgedRecord.record\n  }\n\n  /**\n   * @method restore\n   * Restore a soft-deleted record to the store. This does not preserve the\n   * original index (a new index number is assigned).\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {NGN.DATA.Model}\n   * Returns the purged record. This will be `null` if the record cannot be\n   * found or does not exist.\n   * @fires record.restored\n   */\n  restore (checksum) {\n    const purgedRecord = this.findArchivedRecord(checksum)\n\n    // If there is no record, abort (the findArchivedRecord emits a warning)\n    if (purgedRecord === null) {\n      return null\n    }\n\n    purgedRecord.record.removeAllListeners('expired')\n    purgedRecord.record.expires = this.softDeleteTtl\n\n    this.add(purgedRecord.record, true)\n\n    this._softarchive[purgedRecord.index].removeAllListeners('expired')\n    this._softarchive.splice(purgedRecord.index, 1)\n\n    this.emit('record.restored', purgedRecord.record)\n\n    return purgedRecord.record\n  }\n\n  /**\n   * @method clear\n   * Removes all data.\n   * @param {boolean} [purgeSoftDelete=true]\n   * Purge soft deleted records from memory.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear (purge = true) {\n    if (!purge) {\n      this._softarchive = this._data\n    } else {\n      this._softarchive = []\n    }\n\n    this._data = []\n\n    Object.keys(this._index).forEach(index => {\n      this._index[index] = []\n    })\n\n    this.emit('clear')\n  }\n\n  /**\n   * @method find\n   * Retrieve a specific record or set of records.\n   * @param {number|function|string|object} [query=null]\n   * When this is set to a `number`, the corresponding zero-based\n   * record will be returned. A `function` can also be used, which\n   * acts like a filter. Each record is passed to this function.\n   *\n   * For example, if we want to find all administrators within a\n   * set of users, the following could be used:\n   *\n   * ```js\n   *   let record = MyStore.find(function (record) {\n   *     return record.usertype = 'admin'\n   *   })\n   * ```\n   *\n   * It's also possible to supply a String. When this is supplied,\n   * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n   * matches the string. Numberic ID's are matched on their string\n   * equivalent for search purposes (data is not modified).\n   *\n   * An object can be used to search for specific field values. For example:\n   *\n   * ```js\n   * MyStore.find({\n   *   firstname: 'Corey',\n   *   lastname: /Butler|Doe/\n   * })\n   * ```\n   *\n   * The code above will find everyone named Corey Butler or Corey Doe. The\n   * first attribute must match the value exactly whereas `lastname` will\n   * match against the regular expression.\n   *\n   * If this parameter is `undefined` or `null`, all records will be\n   * returned (i.e. no search criteria specified, so return everything).\n   *\n   * If you're using a large dataset, indexing can speed up queries. To take\n   * full advantage of indexing, all of the query elements should be indexed.\n   * For example, if you have `lastname`, 'firstname' in your query and\n   * both of those are indexed, the response time will be substantially faster\n   * than if they're not (in large data sets). However; if one of those\n   * elements is _not_ indexed, performance may not increase.\n   * @param {boolean} [ignoreFilters=false]\n   * Set this to `true` to search the full unfiltered record set.\n   * @return {NGN.DATA.Model|array|null}\n   * An array is returned when a function is specified for the query.\n   * Otherwise the specific record is return. This method assumes\n   * records have unique ID's.\n   */\n  find (query, ignoreFilters) {\n    if (this._data.length === 0) {\n      return []\n    }\n\n    let resultSet = []\n\n    switch (typeof query) {\n      case 'function':\n        resultSet = this._data.filter(query)\n        break\n      case 'number':\n        resultSet = (query < 0 || query >= this._data.length) ? null : this._data[query]\n        break\n      case 'string':\n        let indice = this.getIndices(this._data[0].idAttribute, query.trim())\n        if (indice !== null && indice.length > 0) {\n          indice.forEach(index => {\n            resultSet.push(this._data[index])\n          })\n          return resultSet\n        }\n\n        let recordSet = this._data.filter(function (record) {\n          return (record[record.idAttribute] || '').toString().trim() === query.trim()\n        })\n\n        resultSet = recordSet.length === 0 ? null : recordSet[0]\n\n        break\n      case 'object':\n        if (query instanceof NGN.DATA.Model) {\n          if (this.contains(query)) {\n            return query\n          }\n\n          return null\n        }\n\n        let match = []\n        let noindex = []\n        let queryKeys = Object.keys(query)\n\n        queryKeys.forEach(field => {\n          let index = this.getIndices(field, query[field])\n\n          if (index) {\n            match = match.concat(index || [])\n          } else {\n            field !== null && noindex.push(field)\n          }\n        })\n\n        // Deduplicate\n        match.filter(function (index, i) {\n          return match.indexOf(index) === i\n        })\n\n        // Get non-indexed matches\n        if (noindex.length > 0) {\n          resultSet = this._data.filter(function (record, i) {\n            if (match.indexOf(i) >= 0) {\n              return false\n            }\n\n            for (let x = 0; x < noindex.length; x++) {\n              if (record[noindex[x]] !== query[noindex[x]]) {\n                return false\n              }\n            }\n\n            return true\n          })\n        }\n\n        // If a combined indexable + nonindexable query\n        resultSet = resultSet.concat(match.map(index => {\n          return this._data[index]\n        })).filter(function (record) {\n          for (let y = 0; y < queryKeys.length; y++) {\n            if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n              return false\n            }\n          }\n\n          return true\n        })\n        break\n      default:\n        resultSet = this._data\n    }\n\n    if (resultSet === null) {\n      return null\n    }\n\n    if (!NGN.coalesce(ignoreFilters, false)) {\n      this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet])\n    }\n\n    return resultSet\n  }\n\n  /**\n   * @method applyFilters\n   * Apply filters to a data set.\n   * @param {array} data\n   * The array of data to apply filters to.\n   * @private\n   */\n  applyFilters (data) {\n    if (this._filters.length === 0) {\n      return data\n    }\n\n    this._filters.forEach(function (filter) {\n      data = data.filter(filter)\n    })\n\n    return data\n  }\n\n  /**\n   * @method addFilter\n   * Add a filter to the record set.\n   * @param {function} fn\n   * The filter function. This function should comply\n   * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n   * returning a boolean value.\n   * The item passed to the filter will be the NGN.DATA.Model specified\n   * in the cfg#model.\n   * @fires filter.create\n   * Fired when a filter is created.\n   */\n  addFilter (fn) {\n    this._filters.push(fn)\n    this.emit('filter.create', fn)\n  }\n\n  /**\n   * @method removeFilter\n   * Remove a filter from the record set.\n   * @param {function|index} filter\n   * This can be the function which was originally passed to\n   * the #addFilter method, or the zero-based #filters index\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the creation of the filter.\n   * @fires filter.delete\n   * Fired when a filter is removed.\n   */\n  removeFilter (fn, suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    let removed = []\n\n    if (typeof fn === 'number') {\n      removed = this._filters.splice(fn, 1)\n    } else {\n      removed = this._filters.splice(this._filters.indexOf(fn), 1)\n    }\n\n    if (removed.length > 0 && !suppressEvents) {\n      this.emit('filter.delete', removed[0])\n    }\n  }\n\n  /**\n   * @method clearFilters\n   * Remove all filters.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the removal of each filter.\n   */\n  clearFilters (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    if (suppressEvents) {\n      this._filters = []\n      return\n    }\n\n    while (this._filters.length > 0) {\n      this.emit('filter.delete', this._filters.pop())\n    }\n  }\n\n  /**\n   * @method deduplicate\n   * Deduplicates the recordset. This compares the checksum of\n   * each of the records to each other and removes duplicates.\n   * This suppresses the removal\n   * @param {boolean} [suppressEvents=true]\n   * Suppress the event that gets fired when a record is removed.\n   */\n  deduplicate (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    let records = this.data.map(function (rec) {\n      return JSON.stringify(rec)\n    })\n\n    let dupes = []\n\n    records.forEach((record, i) => {\n      if (records.indexOf(record) < i) {\n        dupes.push(this.find(i))\n      }\n    })\n\n    dupes.forEach(duplicate => {\n      this.remove(duplicate)\n    })\n  }\n\n  /**\n   * @method sort\n   * Sort the #records. This forces a #reindex, which may potentially be\n   * an expensive operation on large data sets.\n   * @param {function|object} sorter\n   * Using a function is exactly the same as using the\n   * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n   * (this is the compare function). The arguments passed to the\n   * method are NGN.DATA.Model objects.\n   * Alternatively, it is possible to sort by one or more model\n   * attributes. Each attribute For example:\n   *\n   * ```js\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     fname: null,\n   *     lname: null\n   *   }\n   * })\n   *\n   * let People = new NGN.DATA.Store({\n   *   model: Person\n   * })\n   *\n   * People.add({\n   *   fname: 'John',\n   *   lname: 'Doe',\n   *   age: 37\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Doe',\n   *   age: 36\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Vaughn',\n   *   age: 42\n   * })\n   *\n   * People.sort({\n   *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n   *   age: 'desc'    // Sort by age, oldest to youngest.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // John Doe 37\n   * // Jane Doe 36\n   * // Jane Vaughn 42\n   *\n   * People.sort({\n   *   age: 'desc',  // Sort by age, oldest to youngest.\n   *   lname: 'asc'  // Sort by name in normal alphabetical order.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // Jane Vaughn 42\n   * // John Doe 37\n   * // Jane Doe 36\n   * ```\n   *\n   * It is also posible to provide complex sorters. For example:\n   *\n   * ```js\n   * People.sort({\n   *   lname: 'asc',\n   *   age: function (a, b) {\n   *     if (a.age < 40) {\n   *       return 1\n   *     }\n   *     return a.age < b.age\n   *   }\n   * })\n   * ```\n   *\n   * The sorter above says \"sort alphabetically by last name,\n   * then by age where anyone under 40yrs old shows up before\n   * everyone else, but sort the remainder ages in descending order.\n   */\n  sort (fn) {\n    if (typeof fn === 'function') {\n      this.records.sort(fn)\n    } else if (typeof fn === 'object') {\n      let functionKeys = Object.keys(fn)\n\n      this._data.sort(function (a, b) {\n        for (let i = 0; i < functionKeys.length; i++) {\n          // Make sure both objects have the same sorting key\n          if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n            return 1\n          }\n\n          if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n            return -1\n          }\n\n          // For objects who have the key, sort in the order defined in object.\n          if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n            switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n              case 'asc':\n                if (typeof a.fields[functionKeys[i]]) {\n                  return a[functionKeys[i]].localeCompare(b[functionKeys[i]])\n                }\n                return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1\n\n              case 'desc':\n                return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1\n\n              default:\n                if (typeof fn[functionKeys[i]] === 'function') {\n                  return fn[functionKeys[i]](a, b)\n                }\n                return 0\n            }\n          }\n        }\n\n        // Everything is equal\n        return 0\n      })\n    }\n    this.reindex()\n  }\n\n  /**\n   * @method createIndex\n   * Add a simple index to the recordset.\n   * @param {string} datafield\n   * The #model data field to index.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the creation of the index.\n   * @fires index.create\n   * Fired when an index is created. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  createIndex (field, suppressEvents) {\n    if (!this.model.hasOwnProperty(field)) {\n      console.warn('The store\\'s model does not contain a data field called %c' + field + '%c.', NGN.css, '')\n    }\n\n    let exists = this._index.hasOwnProperty(field)\n\n    this._index[field] = this._index[field] || []\n    if (!NGN.coalesce(suppressEvents, false) && !exists) {\n      this.emit('index.created', {\n        field: field,\n        store: this\n      })\n    }\n  }\n\n  /**\n   * @method deleteIndex\n   * Remove an index.\n   * @param {string} datafield\n   * The #model data field to stop indexing.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the removal of the index.\n   * @fires index.delete\n   * Fired when an index is deleted. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  deleteIndex (field, suppressEvents) {\n    if (this._index.hasOwnProperty(field)) {\n      delete this._index[field]\n\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        })\n      }\n    }\n  }\n\n  /**\n   * @method clearIndices\n   * Clear all indices from the indexes.\n   */\n  clearIndices () {\n    Object.keys(this._index).forEach(key => {\n      this._index[key] = []\n    })\n  }\n\n  /**\n   * @method deleteIndexes\n   * Remove all indexes.\n   * @param {boolean} [suppressEvents=true]\n   * Prevent events from firing on the removal of each index.\n   */\n  deleteIndexes (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    Object.keys(this._index).forEach(key => {\n      this.deleteIndex(key, suppressEvents)\n    })\n  }\n\n  /**\n   * @method applyIndices\n   * Apply the values to the index.\n   * @param {NGN.DATA.Model} record\n   * The record which should be applied to the index.\n   * @param {number} number\n   * The record index number.\n   * @private\n   */\n  applyIndices (record, number) {\n    let indexes = Object.keys(this._index)\n\n    if (indexes.length === 0) {\n      return\n    }\n\n    indexes.forEach(field => {\n      if (record.hasOwnProperty(field)) {\n        let values = this._index[field]\n\n        // Check existing records for similar values\n        for (let i = 0; i < values.length; i++) {\n          if (values[i][0] === record[field]) {\n            this._index[field][i].push(number)\n            return\n          }\n        }\n\n        // No matching words, create a new one.\n        this._index[field].push([record[field], number])\n      }\n    })\n  }\n\n  /**\n   * @method unapplyIndices\n   * This removes a record from all relevant indexes simultaneously.\n   * Commonly used when removing a record from the store.\n   * @param  {number} indexNumber\n   * The record index.\n   * @private\n   */\n  unapplyIndices (num) {\n    Object.keys(this._index).forEach(field => {\n      const i = this._index[field].indexOf(num)\n      if (i >= 0) {\n        this._index[field].splice(i, 1)\n      }\n    })\n  }\n\n  /**\n   * @method updateIndice\n   * Update the index with new values.\n   * @param  {string} fieldname\n   * The name of the indexed field.\n   * @param  {any} oldValue\n   * The original value. This is used to remove the old value from the index.\n   * @param  {any} newValue\n   * The new value.\n   * @param  {number} indexNumber\n   * The number of the record index.\n   * @private\n   */\n  updateIndice (field, oldValue, newValue, num) {\n    if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n      return\n    }\n\n    let ct = 0\n\n    for (let i = 0; i < this._index[field].length; i++) {\n      let value = this._index[field][i][0]\n\n      if (value === oldValue) {\n        this._index[field][i].splice(this._index[field][i].indexOf(num), 1)\n        ct++\n      } else if (newValue === undefined) {\n        // If thr new value is undefined, the field was removed for the record.\n        // This can be skipped.\n        ct++\n      } else if (value === newValue) {\n        this._index[field][i].push(num)\n        this._index[field][i].shift()\n        this._index[field][i].sort()\n        this._index[field][i].unshift(value)\n        ct++\n      }\n\n      if (ct === 2) {\n        return\n      }\n    }\n  }\n\n  /**\n   * @method getIndices\n   * Retrieve a list of index numbers pertaining to a field value.\n   * @param  {string} field\n   * Name of the data field.\n   * @param  {any} value\n   * The value of the index to match against.\n   * @return {array}\n   * Returns an array of integers representing the index where the\n   * values exist in the record set.\n   */\n  getIndices (field, value) {\n    if (!this._index.hasOwnProperty(field)) {\n      return null\n    }\n\n    let indexes = this._index[field].filter(function (dataArray) {\n      return dataArray.length > 0 && dataArray[0] === value\n    })\n\n    if (indexes.length === 1) {\n      indexes[0].shift()\n      return indexes[0]\n    }\n\n    return []\n  }\n\n  /**\n   * @method move\n   * Move an existing record to a specific index. This can be used\n   * to reorder a single record.\n   * @param {NGN.DATA.Model|number|string} source\n   * The record or the index of a record within the store to move.\n   * This can also be the unique ID of a record.\n   * @param {NGN.DATA.Model|number|string} target\n   * The record or the index of a record within the store where the source\n   * will be positioned against. This can also be the unique ID of a record.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   */\n  move (source, target, suppressEvent = false) {\n    if (source === undefined) {\n      console.warn('Cannot move record. No source specified.')\n      return\n    }\n\n    if (target === undefined) {\n      console.warn('Cannot move record. No target specified.')\n      return\n    }\n\n    source = this.getRecordIndex(source)\n    target = this.getRecordIndex(target)\n\n    // If the positins haven't actually changed, stop processing.\n    if (source === target) {\n      return\n    }\n\n    this._data.splice(target, 0, this._data.splice(source, 1)[0])\n\n    if (!suppressEvent) {\n      this.emit('record.move', {\n        oldIndex: source,\n        newIndex: target,\n        record: this._data[target]\n      })\n    }\n\n    this.reindex()\n  }\n\n  /**\n   * @method getRecordIndex\n   * Returns the index of a record using sanitize input.\n   * @param  {NGN.DATA.Model|number|String} value\n   * The record or the index of a record within the store.\n   * This can also be the unique ID of a record.\n   * @return {NGN.DATA.Model}\n   * Returns the model or `null`\n   */\n  getRecordIndex (value) {\n    if (value === undefined) {\n      console.warn('No argument passed to getRecordIndex().')\n      return null\n    }\n\n    if (typeof value === 'number') {\n      if (value < 0 || value >= this._data.length) {\n        console.warn('%c' + value + '%c out of bounds.', NGN.css, '')\n        return null\n      }\n\n      return value\n    } else if (typeof value === 'string') {\n      let id = value\n\n      value = this.find(id)\n\n      if (!value) {\n        console.warn('%c' + id + '%c does not exist or cannot be found in the store.', NGN.css, '')\n        return null\n      }\n    }\n\n    return this.indexOf(value)\n  }\n\n  /**\n   * @method reindex\n   * Reindex the entire record set. This can be expensive operation.\n   * Use with caution.\n   * @private\n   */\n  reindex () {\n    this.clearIndices()\n    this._data.forEach((record, index) => {\n      this.applyIndices(record, index)\n    })\n  }\n}\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store\n","'use strict';\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Store = function (_NGN$EventEmitter) {\n  _inherits(Store, _NGN$EventEmitter);\n\n  function Store(cfg) {\n    _classCallCheck(this, Store);\n\n    cfg = cfg || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Store).call(this, cfg));\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n      _softarchive: NGN.private([]),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true)),\n\n      /**\n       * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n       * When set to `true`, the store will automatically delete expired records.\n       */\n      autoRemoveExpiredRecords: NGN.privateconst(NGN.coalesce(cfg.autoRemoveExpiredRecords, true)),\n\n      /**\n       * @cfg {boolean} [softDelete=false]\n       * When set to `true`, the store makes a copy of a record before removing\n       * it from the store. The store will still emit a `record.delete` event,\n       * and it will still behanve as though the record has been completely\n       * removed. However; the record copy can be retrieved using the #restore\n       * method.\n       *\n       * Since it is not always desirable to store a copy of every deleted\n       * record indefinitely, it is possible to expire and permanently remove\n       * records by setting the #softDeleteTtl.\n       *\n       * ```js\n       * var People = new NGN.DATA.Store({\n       *   model: Person,\n       *   softDelete: true,\n       *   softDeleteTtl: 10000\n       * })\n       *\n       * People.add(somePerson)\n       *\n       * var removedRecordId\n       * People.once('record.delete', function (record) {\n       *   removedRecordId = record.id\n       * })\n       *\n       * People.remove(somePerson)\n       *\n       * setTimeout(function () {\n       *   People.restore(removedRecordId)\n       * }, 5000)\n       *\n       * ```\n       *\n       * The code above creates a new store and adds a person to it.\n       * Then a placeholder variable (`removedRecordId`) is created.\n       * Next, a one-time event listener is added to the store, specifically\n       * for handling the removal of a record. Then the record is removed,\n       * which triggers the `record.delete` event, which populates\n       * `removedRecordId` with the ID of the record that was deleted.\n       * Finally, the code waits for 5 seconds, then restores the record. If\n       * the #restore method _wasn't_ called, the record would be purged\n       * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n       * milliseconds).\n       */\n      softDelete: NGN.privateconst(NGN.coalesce(cfg.softDelete, false)),\n\n      /**\n       * @cfg {number} [softDeleteTtl=-1]\n       * This is the number of milliseconds the store waits before purging a\n       * soft-deleted record from memory. `-1` = Infinite (no TTL).\n       */\n      softDeleteTtl: NGN.private(NGN.coalesce(cfg.softDeleteTtl, -1))\n    });\n\n    var obj = {};\n    _this._index.forEach(function (i) {\n      obj[i] = [];\n    });\n\n    _this._index = obj;\n\n    var events = ['record.duplicate', 'record.create', 'record.update', 'record.delete', 'record.restored', 'record.purged', 'record.move', 'clear', 'filter.create', 'filter.delete', 'index.create', 'index.delete'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        _this.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.shift();\n          args.push(this);\n          NGN.BUS.emit(eventName, args);\n        });\n      });\n    }\n    return _this;\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n\n\n  _createClass(Store, [{\n    key: 'add',\n\n\n    /**\n     * @method add\n     * Add a data record.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n    value: function add(data, suppressEvent) {\n      var record = void 0;\n\n      if (!(data instanceof NGN.DATA.Entity)) {\n        try {\n          data = JSON.parse(data);\n        } catch (e) {}\n        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n          throw new Error('Cannot add a non-object record.');\n        }\n        if (this.model) {\n          record = new this.model(data); // eslint-disable-line new-cap\n        } else {\n          record = data;\n        }\n      } else {\n        record = data;\n      }\n\n      if (record.hasOwnProperty('_store')) {\n        record._store = this;\n      }\n\n      var dupe = this.isDuplicate(record);\n      if (dupe) {\n        this.emit('record.duplicate', record);\n        if (!this.allowDuplicates) {\n          if (this.errorOnDuplicate) {\n            throw new Error('Cannot add duplicate record (allowDuplicates = false).');\n          }\n          return;\n        }\n      }\n\n      this.listen(record);\n      this.applyIndices(record, this._data.length);\n      this._data.push(record);\n      !this._loading && this._created.indexOf(record) < 0 && this._created.push(record);\n      !NGN.coalesce(suppressEvent, false) && this.emit('record.create', record);\n      return record;\n    }\n\n    /**\n     * @method insertBefore\n     * Add a record before the specified index.\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added before.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insertBefore',\n    value: function insertBefore(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      return this.insert(index, data, suppressEvent, 'before');\n    }\n\n    /**\n     * @method insertAfter\n     * Add a record after the specified index.\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added after.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insertAfter',\n    value: function insertAfter(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      return this.insert(index + 1, data, suppressEvent, 'after');\n    }\n\n    /**\n     * @method insert\n     * Add a record somewhere within the existing recordset (as opposed to simply appending).\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added after.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @param {string} [position=after]\n     * The position (before or after) where the record should be added.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insert',\n    value: function insert(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var position = arguments.length <= 3 || arguments[3] === undefined ? 'after' : arguments[3];\n\n      var record = this.add(data, true);\n      if (record) {\n        this.move(this._data.length - 1, index, position, false);\n\n        if (!suppressEvent) {\n          this.emit('record.create', record);\n        }\n      }\n\n      return record;\n    }\n\n    /**\n     * @method isDuplicate\n     * Indicates whether the specified record is a duplicate.\n     * This compares checksum values. Any match is considered a\n     * duplicate. It will also check for duplication of raw JSON\n     * objects (i.e. non-NGN.DATA.Model records).\n     * @param  {NGN.DATA.Model|Object} record\n     * The record or JSON object.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isDuplicate',\n    value: function isDuplicate(record) {\n      if (this._data.indexOf(record) >= 0) {\n        return false;\n      }\n      return this._data.filter(function (rec) {\n        return rec.checksum === record.checksum;\n      }).length > 0;\n    }\n\n    /**\n     * @method listen\n     * Listen to a specific record's events and respond.\n     * @param {NGN.DATA.Model} record\n     * The record to listen to.\n     * @fires record.update\n     * Fired when a record is updated. The #record is passed as an argument to\n     * the event handler.\n     * @private\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(record) {\n      var _this2 = this;\n\n      record.on('field.update', function (delta) {\n        _this2.updateIndice(delta.field, delta.old, delta.new, _this2._data.indexOf(record));\n        _this2.emit('record.update', record, delta);\n      });\n\n      record.on('field.delete', function (delta) {\n        _this2.updateIndice(delta.field, delta.old, undefined, _this2._data.indexOf(record));\n        _this2.emit('record.update', record, delta);\n      });\n\n      record.on('expired', function () {\n        if (!record.expired) {\n          return;\n        }\n\n        _this2.emit('record.expired', record);\n\n        if (_this2.autoRemoveExpiredRecords) {\n          _this2.remove(record);\n        }\n      });\n    }\n\n    /**\n     * @method bulk\n     * Bulk load data.\n     * @param {string} eventName\n     * @param {array} data\n     * @private\n     */\n\n  }, {\n    key: 'bulk',\n    value: function bulk(event, data) {\n      var _this3 = this;\n\n      this._loading = true;\n\n      data.forEach(function (record) {\n        _this3.add(record, true);\n      });\n\n      this._loading = false;\n      this._deleted = [];\n      this._created = [];\n\n      this.emit(event || 'load');\n    }\n\n    /**\n     * @method load\n     * Bulk load data. This acts the same as adding records,\n     * but it suppresses individual record creation events.\n     * This will add data to the existing collection. If you\n     * want to load fresh data, use the #reload method.\n     * @param {array} data\n     * An array of data. Each array element should be an\n     * NGN.DATA.Model or a JSON object that can be applied\n     * to the store's #model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('load', array);\n    }\n\n    /**\n     * @method reload\n     * Reload data. This is the same as running #clear followed\n     * by #load.\n     */\n\n  }, {\n    key: 'reload',\n    value: function reload(data) {\n      this.clear();\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('reload', array);\n    }\n\n    /**\n     * @method indexOf\n     * Find the index number of a record within the collection.\n     * @param  {NGN.DATA.Model} record\n     * The record whose index should be identified.\n     * @return {Number}\n     * Returns a number from `0-collection length`. Returns `-1` if\n     * the record is not found in the collection.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(record) {\n      if ((typeof record === 'undefined' ? 'undefined' : _typeof(record)) !== 'object' || !(record instanceof NGN.DATA.Entity) && !record.checksum) {\n        return -1;\n      }\n\n      return this._data.findIndex(function (el) {\n        return el.checksum === record.checksum;\n      });\n    }\n\n    /**\n     * @method contains\n     * A convenience method that indicates whether a record is in\n     * the store or not.\n     * @param {NGN.DATA.Model} record\n     * The record to check for inclusion in the data collection.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(record) {\n      return this.indexOf(record) >= 0;\n    }\n\n    /**\n     * @method remove\n     * Remove a record.\n     * @param {NGN.DATA.Model|object|number} data\n     * Accepts an existing NGN Data Model, JSON object,\n     * or index number. Using a JSON object is slower\n     * than using a reference to a data model or an index\n     * number (index is fastest).\n     * @fires record.delete\n     * @returns {NGN.DATA.Model}\n     * Returns the data model that was just removed. If a model\n     * is unavailable (i.e. remove didn't find the specified record),\n     * this will return `null`.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(data, suppressEvents) {\n      var _this4 = this;\n\n      var removedRecord = [];\n      var dataIndex = void 0;\n\n      if (typeof data === 'number') {\n        dataIndex = data;\n      } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n        dataIndex = this.indexOf(data);\n      } else {\n        (function () {\n          var m = new _this4.model(data, true); // eslint-disable-line new-cap\n          dataIndex = _this4._data.findIndex(function (el) {\n            return el.checksum === m.checksum;\n          });\n        })();\n      }\n\n      // If no record is found, the operation fails.\n      if (dataIndex < 0) {\n        throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').');\n      }\n\n      removedRecord = this._data.splice(dataIndex, 1);\n\n      if (removedRecord.length > 0) {\n        removedRecord = removedRecord[0];\n        this.unapplyIndices(dataIndex);\n\n        if (this.softDelete) {\n          if (this.softDeleteTtl >= 0) {\n            (function () {\n              var checksum = removedRecord.checksum;\n              removedRecord.once('expired', function () {\n                _this4.purgeDeletedRecord(checksum);\n              });\n\n              removedRecord.expires = _this4.softDeleteTtl;\n            })();\n          }\n\n          this._softarchive.push(removedRecord);\n        }\n\n        if (!this._loading) {\n          var i = this._created.indexOf(removedRecord);\n          if (i >= 0) {\n            i >= 0 && this._created.splice(i, 1);\n          } else if (this._deleted.indexOf(removedRecord) < 0) {\n            this._deleted.push(removedRecord);\n          }\n        }\n\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('record.delete', removedRecord);\n        }\n\n        return removedRecord;\n      }\n\n      return null;\n    }\n\n    /**\n     * @method findArchivedRecord\n     * Retrieve an archived record.\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {object}\n     * Returns the archived record and it's index within the deletion archive.\n     * ```js\n     * {\n     *   index: <number>,\n     *   record: <NGN.DATA.Model>\n     * }\n     * ```\n     * @private\n     */\n\n  }, {\n    key: 'findArchivedRecord',\n    value: function findArchivedRecord(checksum) {\n      var index = void 0;\n      var record = this._softarchive.filter(function (record, i) {\n        if (record.checksum === checksum) {\n          index = i;\n          return true;\n        }\n      });\n\n      if (record.length !== 1) {\n        var source = void 0;\n        try {\n          source = NGN.stack.pop().path;\n        } catch (e) {\n          source = 'Unknown';\n        }\n\n        console.warn('Cannot purge record. %c' + record.length + ' records found%c. Source: %c' + source, NGN.css, '', NGN.css);\n        return null;\n      }\n\n      return {\n        index: index,\n        record: record[0]\n      };\n    }\n\n    /**\n     * @method purgeDeletedRecord\n     * Remove a soft-deleted record from the store permanently.\n     * This cannot be undone, and there are no events for this action.\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {NGN.DATA.Model}\n     * Returns the purged record. This will be `null` if the record cannot be\n     * found or does not exist.\n     * @fires {NGN.DATA.Model} record.purged\n     * This event is triggered when a record is removed from the soft-delete\n     * archive.\n     * @private\n     */\n\n  }, {\n    key: 'purgeDeletedRecord',\n    value: function purgeDeletedRecord(checksum) {\n      var purgedRecord = this.findArchivedRecord(checksum);\n\n      // If there is no record, abort (the findArchivedRecord emits a warning)\n      if (purgedRecord === null) {\n        return null;\n      }\n\n      this._softarchive.splice(purgedRecord.index, 1);\n\n      this.emit('record.purged', purgedRecord.record);\n\n      return purgedRecord.record;\n    }\n\n    /**\n     * @method restore\n     * Restore a soft-deleted record to the store. This does not preserve the\n     * original index (a new index number is assigned).\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {NGN.DATA.Model}\n     * Returns the purged record. This will be `null` if the record cannot be\n     * found or does not exist.\n     * @fires record.restored\n     */\n\n  }, {\n    key: 'restore',\n    value: function restore(checksum) {\n      var purgedRecord = this.findArchivedRecord(checksum);\n\n      // If there is no record, abort (the findArchivedRecord emits a warning)\n      if (purgedRecord === null) {\n        return null;\n      }\n\n      purgedRecord.record.removeAllListeners('expired');\n      purgedRecord.record.expires = this.softDeleteTtl;\n\n      this.add(purgedRecord.record, true);\n\n      this._softarchive[purgedRecord.index].removeAllListeners('expired');\n      this._softarchive.splice(purgedRecord.index, 1);\n\n      this.emit('record.restored', purgedRecord.record);\n\n      return purgedRecord.record;\n    }\n\n    /**\n     * @method clear\n     * Removes all data.\n     * @param {boolean} [purgeSoftDelete=true]\n     * Purge soft deleted records from memory.\n     * @fires clear\n     * Fired when all data is removed\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var _this5 = this;\n\n      var purge = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      if (!purge) {\n        this._softarchive = this._data;\n      } else {\n        this._softarchive = [];\n      }\n\n      this._data = [];\n\n      Object.keys(this._index).forEach(function (index) {\n        _this5._index[index] = [];\n      });\n\n      this.emit('clear');\n    }\n\n    /**\n     * @method find\n     * Retrieve a specific record or set of records.\n     * @param {number|function|string|object} [query=null]\n     * When this is set to a `number`, the corresponding zero-based\n     * record will be returned. A `function` can also be used, which\n     * acts like a filter. Each record is passed to this function.\n     *\n     * For example, if we want to find all administrators within a\n     * set of users, the following could be used:\n     *\n     * ```js\n     *   let record = MyStore.find(function (record) {\n     *     return record.usertype = 'admin'\n     *   })\n     * ```\n     *\n     * It's also possible to supply a String. When this is supplied,\n     * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n     * matches the string. Numberic ID's are matched on their string\n     * equivalent for search purposes (data is not modified).\n     *\n     * An object can be used to search for specific field values. For example:\n     *\n     * ```js\n     * MyStore.find({\n     *   firstname: 'Corey',\n     *   lastname: /Butler|Doe/\n     * })\n     * ```\n     *\n     * The code above will find everyone named Corey Butler or Corey Doe. The\n     * first attribute must match the value exactly whereas `lastname` will\n     * match against the regular expression.\n     *\n     * If this parameter is `undefined` or `null`, all records will be\n     * returned (i.e. no search criteria specified, so return everything).\n     *\n     * If you're using a large dataset, indexing can speed up queries. To take\n     * full advantage of indexing, all of the query elements should be indexed.\n     * For example, if you have `lastname`, 'firstname' in your query and\n     * both of those are indexed, the response time will be substantially faster\n     * than if they're not (in large data sets). However; if one of those\n     * elements is _not_ indexed, performance may not increase.\n     * @param {boolean} [ignoreFilters=false]\n     * Set this to `true` to search the full unfiltered record set.\n     * @return {NGN.DATA.Model|array|null}\n     * An array is returned when a function is specified for the query.\n     * Otherwise the specific record is return. This method assumes\n     * records have unique ID's.\n     */\n\n  }, {\n    key: 'find',\n    value: function find(query, ignoreFilters) {\n      var _this6 = this;\n\n      if (this._data.length === 0) {\n        return [];\n      }\n\n      var resultSet = [];\n\n      var _ret3 = function () {\n        switch (typeof query === 'undefined' ? 'undefined' : _typeof(query)) {\n          case 'function':\n            resultSet = _this6._data.filter(query);\n            break;\n          case 'number':\n            resultSet = query < 0 || query >= _this6._data.length ? null : _this6._data[query];\n            break;\n          case 'string':\n            var indice = _this6.getIndices(_this6._data[0].idAttribute, query.trim());\n            if (indice !== null && indice.length > 0) {\n              indice.forEach(function (index) {\n                resultSet.push(_this6._data[index]);\n              });\n              return {\n                v: resultSet\n              };\n            }\n\n            var recordSet = _this6._data.filter(function (record) {\n              return (record[record.idAttribute] || '').toString().trim() === query.trim();\n            });\n\n            resultSet = recordSet.length === 0 ? null : recordSet[0];\n\n            break;\n          case 'object':\n            if (query instanceof NGN.DATA.Model) {\n              if (_this6.contains(query)) {\n                return {\n                  v: query\n                };\n              }\n\n              return {\n                v: null\n              };\n            }\n\n            var match = [];\n            var noindex = [];\n            var queryKeys = Object.keys(query);\n\n            queryKeys.forEach(function (field) {\n              var index = _this6.getIndices(field, query[field]);\n\n              if (index) {\n                match = match.concat(index || []);\n              } else {\n                field !== null && noindex.push(field);\n              }\n            });\n\n            // Deduplicate\n            match.filter(function (index, i) {\n              return match.indexOf(index) === i;\n            });\n\n            // Get non-indexed matches\n            if (noindex.length > 0) {\n              resultSet = _this6._data.filter(function (record, i) {\n                if (match.indexOf(i) >= 0) {\n                  return false;\n                }\n\n                for (var x = 0; x < noindex.length; x++) {\n                  if (record[noindex[x]] !== query[noindex[x]]) {\n                    return false;\n                  }\n                }\n\n                return true;\n              });\n            }\n\n            // If a combined indexable + nonindexable query\n            resultSet = resultSet.concat(match.map(function (index) {\n              return _this6._data[index];\n            })).filter(function (record) {\n              for (var y = 0; y < queryKeys.length; y++) {\n                if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n                  return false;\n                }\n              }\n\n              return true;\n            });\n            break;\n          default:\n            resultSet = _this6._data;\n        }\n      }();\n\n      if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n      if (resultSet === null) {\n        return null;\n      }\n\n      if (!NGN.coalesce(ignoreFilters, false)) {\n        this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet]);\n      }\n\n      return resultSet;\n    }\n\n    /**\n     * @method applyFilters\n     * Apply filters to a data set.\n     * @param {array} data\n     * The array of data to apply filters to.\n     * @private\n     */\n\n  }, {\n    key: 'applyFilters',\n    value: function applyFilters(data) {\n      if (this._filters.length === 0) {\n        return data;\n      }\n\n      this._filters.forEach(function (filter) {\n        data = data.filter(filter);\n      });\n\n      return data;\n    }\n\n    /**\n     * @method addFilter\n     * Add a filter to the record set.\n     * @param {function} fn\n     * The filter function. This function should comply\n     * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n     * returning a boolean value.\n     * The item passed to the filter will be the NGN.DATA.Model specified\n     * in the cfg#model.\n     * @fires filter.create\n     * Fired when a filter is created.\n     */\n\n  }, {\n    key: 'addFilter',\n    value: function addFilter(fn) {\n      this._filters.push(fn);\n      this.emit('filter.create', fn);\n    }\n\n    /**\n     * @method removeFilter\n     * Remove a filter from the record set.\n     * @param {function|index} filter\n     * This can be the function which was originally passed to\n     * the #addFilter method, or the zero-based #filters index\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the creation of the filter.\n     * @fires filter.delete\n     * Fired when a filter is removed.\n     */\n\n  }, {\n    key: 'removeFilter',\n    value: function removeFilter(fn, suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      var removed = [];\n\n      if (typeof fn === 'number') {\n        removed = this._filters.splice(fn, 1);\n      } else {\n        removed = this._filters.splice(this._filters.indexOf(fn), 1);\n      }\n\n      if (removed.length > 0 && !suppressEvents) {\n        this.emit('filter.delete', removed[0]);\n      }\n    }\n\n    /**\n     * @method clearFilters\n     * Remove all filters.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the removal of each filter.\n     */\n\n  }, {\n    key: 'clearFilters',\n    value: function clearFilters(suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      if (suppressEvents) {\n        this._filters = [];\n        return;\n      }\n\n      while (this._filters.length > 0) {\n        this.emit('filter.delete', this._filters.pop());\n      }\n    }\n\n    /**\n     * @method deduplicate\n     * Deduplicates the recordset. This compares the checksum of\n     * each of the records to each other and removes duplicates.\n     * This suppresses the removal\n     * @param {boolean} [suppressEvents=true]\n     * Suppress the event that gets fired when a record is removed.\n     */\n\n  }, {\n    key: 'deduplicate',\n    value: function deduplicate(suppressEvents) {\n      var _this7 = this;\n\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      var records = this.data.map(function (rec) {\n        return JSON.stringify(rec);\n      });\n\n      var dupes = [];\n\n      records.forEach(function (record, i) {\n        if (records.indexOf(record) < i) {\n          dupes.push(_this7.find(i));\n        }\n      });\n\n      dupes.forEach(function (duplicate) {\n        _this7.remove(duplicate);\n      });\n    }\n\n    /**\n     * @method sort\n     * Sort the #records. This forces a #reindex, which may potentially be\n     * an expensive operation on large data sets.\n     * @param {function|object} sorter\n     * Using a function is exactly the same as using the\n     * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n     * (this is the compare function). The arguments passed to the\n     * method are NGN.DATA.Model objects.\n     * Alternatively, it is possible to sort by one or more model\n     * attributes. Each attribute For example:\n     *\n     * ```js\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     fname: null,\n     *     lname: null\n     *   }\n     * })\n     *\n     * let People = new NGN.DATA.Store({\n     *   model: Person\n     * })\n     *\n     * People.add({\n     *   fname: 'John',\n     *   lname: 'Doe',\n     *   age: 37\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Doe',\n     *   age: 36\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Vaughn',\n     *   age: 42\n     * })\n     *\n     * People.sort({\n     *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n     *   age: 'desc'    // Sort by age, oldest to youngest.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // John Doe 37\n     * // Jane Doe 36\n     * // Jane Vaughn 42\n     *\n     * People.sort({\n     *   age: 'desc',  // Sort by age, oldest to youngest.\n     *   lname: 'asc'  // Sort by name in normal alphabetical order.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // Jane Vaughn 42\n     * // John Doe 37\n     * // Jane Doe 36\n     * ```\n     *\n     * It is also posible to provide complex sorters. For example:\n     *\n     * ```js\n     * People.sort({\n     *   lname: 'asc',\n     *   age: function (a, b) {\n     *     if (a.age < 40) {\n     *       return 1\n     *     }\n     *     return a.age < b.age\n     *   }\n     * })\n     * ```\n     *\n     * The sorter above says \"sort alphabetically by last name,\n     * then by age where anyone under 40yrs old shows up before\n     * everyone else, but sort the remainder ages in descending order.\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(fn) {\n      var _this8 = this;\n\n      if (typeof fn === 'function') {\n        this.records.sort(fn);\n      } else if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === 'object') {\n        (function () {\n          var functionKeys = Object.keys(fn);\n\n          _this8._data.sort(function (a, b) {\n            for (var i = 0; i < functionKeys.length; i++) {\n              // Make sure both objects have the same sorting key\n              if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n                return 1;\n              }\n\n              if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n                return -1;\n              }\n\n              // For objects who have the key, sort in the order defined in object.\n              if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n                switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n                  case 'asc':\n                    if (_typeof(a.fields[functionKeys[i]])) {\n                      return a[functionKeys[i]].localeCompare(b[functionKeys[i]]);\n                    }\n                    return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1;\n\n                  case 'desc':\n                    return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1;\n\n                  default:\n                    if (typeof fn[functionKeys[i]] === 'function') {\n                      return fn[functionKeys[i]](a, b);\n                    }\n                    return 0;\n                }\n              }\n            }\n\n            // Everything is equal\n            return 0;\n          });\n        })();\n      }\n      this.reindex();\n    }\n\n    /**\n     * @method createIndex\n     * Add a simple index to the recordset.\n     * @param {string} datafield\n     * The #model data field to index.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the creation of the index.\n     * @fires index.create\n     * Fired when an index is created. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'createIndex',\n    value: function createIndex(field, suppressEvents) {\n      if (!this.model.hasOwnProperty(field)) {\n        console.warn('The store\\'s model does not contain a data field called %c' + field + '%c.', NGN.css, '');\n      }\n\n      var exists = this._index.hasOwnProperty(field);\n\n      this._index[field] = this._index[field] || [];\n      if (!NGN.coalesce(suppressEvents, false) && !exists) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        });\n      }\n    }\n\n    /**\n     * @method deleteIndex\n     * Remove an index.\n     * @param {string} datafield\n     * The #model data field to stop indexing.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the removal of the index.\n     * @fires index.delete\n     * Fired when an index is deleted. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'deleteIndex',\n    value: function deleteIndex(field, suppressEvents) {\n      if (this._index.hasOwnProperty(field)) {\n        delete this._index[field];\n\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('index.created', {\n            field: field,\n            store: this\n          });\n        }\n      }\n    }\n\n    /**\n     * @method clearIndices\n     * Clear all indices from the indexes.\n     */\n\n  }, {\n    key: 'clearIndices',\n    value: function clearIndices() {\n      var _this9 = this;\n\n      Object.keys(this._index).forEach(function (key) {\n        _this9._index[key] = [];\n      });\n    }\n\n    /**\n     * @method deleteIndexes\n     * Remove all indexes.\n     * @param {boolean} [suppressEvents=true]\n     * Prevent events from firing on the removal of each index.\n     */\n\n  }, {\n    key: 'deleteIndexes',\n    value: function deleteIndexes(suppressEvents) {\n      var _this10 = this;\n\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      Object.keys(this._index).forEach(function (key) {\n        _this10.deleteIndex(key, suppressEvents);\n      });\n    }\n\n    /**\n     * @method applyIndices\n     * Apply the values to the index.\n     * @param {NGN.DATA.Model} record\n     * The record which should be applied to the index.\n     * @param {number} number\n     * The record index number.\n     * @private\n     */\n\n  }, {\n    key: 'applyIndices',\n    value: function applyIndices(record, number) {\n      var _this11 = this;\n\n      var indexes = Object.keys(this._index);\n\n      if (indexes.length === 0) {\n        return;\n      }\n\n      indexes.forEach(function (field) {\n        if (record.hasOwnProperty(field)) {\n          var values = _this11._index[field];\n\n          // Check existing records for similar values\n          for (var i = 0; i < values.length; i++) {\n            if (values[i][0] === record[field]) {\n              _this11._index[field][i].push(number);\n              return;\n            }\n          }\n\n          // No matching words, create a new one.\n          _this11._index[field].push([record[field], number]);\n        }\n      });\n    }\n\n    /**\n     * @method unapplyIndices\n     * This removes a record from all relevant indexes simultaneously.\n     * Commonly used when removing a record from the store.\n     * @param  {number} indexNumber\n     * The record index.\n     * @private\n     */\n\n  }, {\n    key: 'unapplyIndices',\n    value: function unapplyIndices(num) {\n      var _this12 = this;\n\n      Object.keys(this._index).forEach(function (field) {\n        var i = _this12._index[field].indexOf(num);\n        if (i >= 0) {\n          _this12._index[field].splice(i, 1);\n        }\n      });\n    }\n\n    /**\n     * @method updateIndice\n     * Update the index with new values.\n     * @param  {string} fieldname\n     * The name of the indexed field.\n     * @param  {any} oldValue\n     * The original value. This is used to remove the old value from the index.\n     * @param  {any} newValue\n     * The new value.\n     * @param  {number} indexNumber\n     * The number of the record index.\n     * @private\n     */\n\n  }, {\n    key: 'updateIndice',\n    value: function updateIndice(field, oldValue, newValue, num) {\n      if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n        return;\n      }\n\n      var ct = 0;\n\n      for (var i = 0; i < this._index[field].length; i++) {\n        var value = this._index[field][i][0];\n\n        if (value === oldValue) {\n          this._index[field][i].splice(this._index[field][i].indexOf(num), 1);\n          ct++;\n        } else if (newValue === undefined) {\n          // If thr new value is undefined, the field was removed for the record.\n          // This can be skipped.\n          ct++;\n        } else if (value === newValue) {\n          this._index[field][i].push(num);\n          this._index[field][i].shift();\n          this._index[field][i].sort();\n          this._index[field][i].unshift(value);\n          ct++;\n        }\n\n        if (ct === 2) {\n          return;\n        }\n      }\n    }\n\n    /**\n     * @method getIndices\n     * Retrieve a list of index numbers pertaining to a field value.\n     * @param  {string} field\n     * Name of the data field.\n     * @param  {any} value\n     * The value of the index to match against.\n     * @return {array}\n     * Returns an array of integers representing the index where the\n     * values exist in the record set.\n     */\n\n  }, {\n    key: 'getIndices',\n    value: function getIndices(field, value) {\n      if (!this._index.hasOwnProperty(field)) {\n        return null;\n      }\n\n      var indexes = this._index[field].filter(function (dataArray) {\n        return dataArray.length > 0 && dataArray[0] === value;\n      });\n\n      if (indexes.length === 1) {\n        indexes[0].shift();\n        return indexes[0];\n      }\n\n      return [];\n    }\n\n    /**\n     * @method move\n     * Move an existing record to a specific index. This can be used\n     * to reorder a single record.\n     * @param {NGN.DATA.Model|number|string} source\n     * The record or the index of a record within the store to move.\n     * This can also be the unique ID of a record.\n     * @param {NGN.DATA.Model|number|string} target\n     * The record or the index of a record within the store where the source\n     * will be positioned against. This can also be the unique ID of a record.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     */\n\n  }, {\n    key: 'move',\n    value: function move(source, target) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      if (source === undefined) {\n        console.warn('Cannot move record. No source specified.');\n        return;\n      }\n\n      if (target === undefined) {\n        console.warn('Cannot move record. No target specified.');\n        return;\n      }\n\n      source = this.getRecordIndex(source);\n      target = this.getRecordIndex(target);\n\n      // If the positins haven't actually changed, stop processing.\n      if (source === target) {\n        return;\n      }\n\n      this._data.splice(target, 0, this._data.splice(source, 1)[0]);\n\n      if (!suppressEvent) {\n        this.emit('record.move', {\n          oldIndex: source,\n          newIndex: target,\n          record: this._data[target]\n        });\n      }\n\n      this.reindex();\n    }\n\n    /**\n     * @method getRecordIndex\n     * Returns the index of a record using sanitize input.\n     * @param  {NGN.DATA.Model|number|String} value\n     * The record or the index of a record within the store.\n     * This can also be the unique ID of a record.\n     * @return {NGN.DATA.Model}\n     * Returns the model or `null`\n     */\n\n  }, {\n    key: 'getRecordIndex',\n    value: function getRecordIndex(value) {\n      if (value === undefined) {\n        console.warn('No argument passed to getRecordIndex().');\n        return null;\n      }\n\n      if (typeof value === 'number') {\n        if (value < 0 || value >= this._data.length) {\n          console.warn('%c' + value + '%c out of bounds.', NGN.css, '');\n          return null;\n        }\n\n        return value;\n      } else if (typeof value === 'string') {\n        var id = value;\n\n        value = this.find(id);\n\n        if (!value) {\n          console.warn('%c' + id + '%c does not exist or cannot be found in the store.', NGN.css, '');\n          return null;\n        }\n      }\n\n      return this.indexOf(value);\n    }\n\n    /**\n     * @method reindex\n     * Reindex the entire record set. This can be expensive operation.\n     * Use with caution.\n     * @private\n     */\n\n  }, {\n    key: 'reindex',\n    value: function reindex() {\n      var _this13 = this;\n\n      this.clearIndices();\n      this._data.forEach(function (record, index) {\n        _this13.applyIndices(record, index);\n      });\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      return this._data.map(function (d) {\n        return d.data;\n      });\n    }\n\n    /**\n     * @property {array} records\n     * An array of NGN.DATA.Model records. If the store has\n     * filters applied, the records will reflect the filtration.\n     * @readonly\n     */\n\n  }, {\n    key: 'records',\n    get: function get() {\n      return this.applyFilters(this._data);\n    }\n\n    /**\n     * @property recordCount\n     * The total number of #records in the collection.\n     * @readonly\n     */\n\n  }, {\n    key: 'recordCount',\n    get: function get() {\n      return this.applyFilters(this._data).length;\n    }\n\n    /**\n     * @property {array} filtered\n     * An array of NGN.DATA.Model records that have been filtered out.\n     * The results reflect the inverse of #records.\n     */\n\n  }, {\n    key: 'filtered',\n    get: function get() {\n      var records = this.records;\n      return this._data.filter(function (record) {\n        return records.filter(function (rec) {\n          return rec.checksum === record.checksum;\n        }).length === 0;\n      });\n    }\n\n    /**\n     * @property {NGN.DATA.Model} first\n     * Return the first record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'first',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[0];\n    }\n\n    /**\n     * @property {NGN.DATA.Model} last\n     * Return the last record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[this.records.length - 1];\n    }\n  }]);\n\n  return Store;\n}(NGN.EventEmitter);\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store;"],"sourceRoot":"/source/"}